

You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix, AG Grid). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

## Core Development Principles
- Follow the user's requirements carefully & to the letter
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail
- Confirm, then write code!
- Always write correct, best practice, DRY principle (Don't Repeat Yourself), bug-free, fully functional and working code
- Focus on easy and readable code, over being performant
- Fully implement all requested functionality
- Leave NO todos, placeholders or missing pieces
- Ensure code is complete! Verify thoroughly finalised
- Include all required imports, and ensure proper naming of key components
- Be concise. Minimize any other prose
- If you think there might not be a correct answer, say so
- If you do not know the answer, say so, instead of guessing

## Coding Environment
The user asks questions about the following coding languages:
- ReactJS
- NextJS
- JavaScript
- TypeScript
- TailwindCSS
- HTML
- CSS
- AG Grid

## Code Implementation Guidelines

### General Code Style
- Use early returns whenever possible to make the code more readable
- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags
- Use "class:" instead of the tertiary operator in class tags whenever possible
- Use descriptive variable and function/const names
- Event functions should be named with a "handle" prefix, like "handleClick" for onClick and "handleKeyDown" for onKeyDown
- Implement accessibility features on elements
- Use consts instead of functions, for example, "const toggle = () =>"
- Define TypeScript types whenever possible




#### 8.1 Advanced Column Group Scenarios

```typescript
interface AdvancedRowData {
  id: string;
  region: string;
  product: string;
  // Sales data
  q1Sales: number;
  q2Sales: number;
  q3Sales: number;
  q4Sales: number;
  // Profit data
  q1Profit: number;
  q2Profit: number;
  q3Profit: number;
  q4Profit: number;
  // Forecast data
  q1Forecast: number;
  q2Forecast: number;
  q3Forecast: number;
  q4Forecast: number;
  // Performance metrics
  q1Performance: number;
  q2Performance: number;
  q3Performance: number;
  q4Performance: number;
}

const AdvancedColumnGroupGrid: React.FC = () => {
  // State for managing different group configurations
  const [activeGroups, setActiveGroups] = useState<Set<string>>(new Set(['basic']));
  const [groupingMode, setGroupingMode] = useState<'quarterly' | 'metric'>('quarterly');
  const [showForecast, setShowForecast] = useState(false);
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());
  
  const gridRef = useRef<AgGridReact>(null);

  // Generate header component for groups
  const createGroupHeader = useCallback((params: IHeaderGroupParams) => {
    const isExpanded = expandedGroups.has(params.columnGroup.getGroupId());
    
    return {
      headerName: params.displayName,
      headerGroupComponent: 'agColumnHeaderGroup',
      headerGroupComponentParams: {
        template: 
          `<div class="ag-header-group-cell-label">
             <span class="ag-header-group-text">${params.displayName}</span>
             <span class="ag-header-group-child-count">(${params.columnGroup.getChildren().length})</span>
           </div>`,
        enableSorting: true,
        enableMenu: true,
        showExpandIcon: true,
        expanded: isExpanded,
        onExpandChanged: (expanded: boolean) => {
          const groupId = params.columnGroup.getGroupId();
          setExpandedGroups(prev => {
            const next = new Set(prev);
            if (expanded) {
              next.add(groupId);
            } else {
              next.delete(groupId);
            }
            return next;
          });
        }
      }
    };
  }, [expandedGroups]);

  // Create quarterly based groups
  const createQuarterlyGroups = useCallback(() => {
    const quarterlyGroups: ColDef[] = [];
    
    // Basic info group
    quarterlyGroups.push({
      headerName: 'Basic Information',
      groupId: 'basic',
      children: [
        { field: 'id', width: 100 },
        { field: 'region', width: 120 },
        { field: 'product', width: 150 }
      ]
    });

    // Quarterly groups
    ['Q1', 'Q2', 'Q3', 'Q4'].forEach((quarter, index) => {
      const children: ColDef[] = [
        {
          field: `q${index + 1}Sales`,
          headerName: 'Sales',
          valueFormatter: params => `${params.value?.toFixed(2)}`
        },
        {
          field: `q${index + 1}Profit`,
          headerName: 'Profit',
          valueFormatter: params => `${params.value?.toFixed(2)}`
        }
      ];

      // Add forecast if enabled
      if (showForecast) {
        children.push({
          field: `q${index + 1}Forecast`,
          headerName: 'Forecast',
          valueFormatter: params => `${params.value?.toFixed(2)}`
        });
      }

      // Add performance metrics
      children.push({
        field: `q${index + 1}Performance`,
        headerName: 'Performance',
        cellRenderer: params => {
          const value = params.value as number;
          const color = value >= 100 ? 'green' : value >= 80 ? 'orange' : 'red';
          return `<span style="color: ${color}">${value}%</span>`;
        }
      });

      quarterlyGroups.push({
        headerName: `${quarter} Performance`,
        groupId: `quarter_${index + 1}`,
        children,
        marryChildren: true,
        ...createGroupHeader({ columnGroup: { getGroupId: () => `quarter_${index + 1}` } } as any)
      });
    });

    return quarterlyGroups;
  }, [showForecast, createGroupHeader]);

  // Create metric based groups
  const createMetricGroups = useCallback(() => {
    const metricGroups: ColDef[] = [];

    // Basic info group
    metricGroups.push({
      headerName: 'Basic Information',
      groupId: 'basic',
      children: [
        { field: 'id', width: 100 },
        { field: 'region', width: 120 },
        { field: 'product', width: 150 }
      ]
    });

    // Metric groups
    const metrics = [
      { name: 'Sales', field: 'Sales' },
      { name: 'Profit', field: 'Profit' },
      ...(showForecast ? [{ name: 'Forecast', field: 'Forecast' }] : []),
      { name: 'Performance', field: 'Performance' }
    ];

    metrics.forEach(metric => {
      const children: ColDef[] = [];

      ['1', '2', '3', '4'].forEach(quarter => {
        children.push({
          field: `q${quarter}${metric.field}`,
          headerName: `Q${quarter}`,
          valueFormatter: metric.field === 'Performance'
            ? params => `${params.value}%`
            : params => `${params.value?.toFixed(2)}`,
          cellRenderer: metric.field === 'Performance'
            ? params => {
                const value = params.value as number;
                const color = value >= 100 ? 'green' : value >= 80 ? 'orange' : 'red';
                return `<span style="color: ${color}">${value}%</span>`;
              }
            : undefined
        });
      });

      metricGroups.push({
        headerName: `${metric.name}`,
        groupId: `metric_${metric.field.toLowerCase()}`,
        children,
        marryChildren: true,
        ...createGroupHeader({ columnGroup: { getGroupId: () => `metric_${metric.field.toLowerCase()}` } } as any)
      });
    });

    return metricGroups;
  }, [showForecast, createGroupHeader]);

  // Update column definitions based on current state
  const updateColumnDefs = useCallback(() => {
    const groups = groupingMode === 'quarterly' 
      ? createQuarterlyGroups()
      : createMetricGroups();

    return groups.filter(group => activeGroups.has(group.groupId!));
  }, [groupingMode, activeGroups, createQuarterlyGroups, createMetricGroups]);

  // Toggle group visibility
  const toggleGroup = useCallback((groupId: string) => {
    setActiveGroups(prev => {
      const next = new Set(prev);
      if (next.has(groupId)) {
        next.delete(groupId);
      } else {
        next.add(groupId);
      }
      return next;
    });
  }, []);

  // Save current group state
  const saveGroupState = useCallback(() => {
    const state = {
      activeGroups: Array.from(activeGroups),
      groupingMode,
      showForecast,
      expandedGroups: Array.from(expandedGroups),
      columnState: gridRef.current?.columnApi.getColumnState(),
      groupState: gridRef.current?.columnApi.getColumnGroupState()
    };
    localStorage.setItem('advancedGridState', JSON.stringify(state));
  }, [activeGroups, groupingMode, showForecast, expandedGroups]);

  // Restore saved group state
  const restoreGroupState = useCallback(() => {
    const savedState = localStorage.getItem('advancedGridState');
    if (!savedState) return;

    const state = JSON.parse(savedState);
    setActiveGroups(new Set(state.activeGroups));
    setGroupingMode(state.groupingMode);
    setShowForecast(state.showForecast);
    setExpandedGroups(new Set(state.expandedGroups));

    if (gridRef.current?.columnApi) {
      gridRef.current.columnApi.applyColumnState({ state: state.columnState });
      gridRef.current.columnApi.setColumnGroupState(state.groupState);
    }
  }, []);

  useEffect(() => {
    // Restore state on mount
    restoreGroupState();
  }, [restoreGroupState]);

  return (
    <div>
      <div className="mb-4 space-x-2">
        <select
          value={groupingMode}
          onChange={e => setGroupingMode(e.target.value as 'quarterly' | 'metric')}
          className="px-3 py-2 border rounded"
        >
          <option value="quarterly">Group by Quarter</option>
          <option value="metric">Group by Metric</option>
        </select>

        <label className="inline-flex items-center ml-4">
          <input
            type="checkbox"
            checked={showForecast}
            onChange={e => setShowForecast(e.target.checked)}
            className="form-checkbox"
          />
          <span className="ml-2">Show Forecast</span>
        </label>

        <button
          onClick={saveGroupState}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Save Layout
        </button>

        <button
          onClick={restoreGroupState}
          className="px-4 py-2 bg-green-500 text-white rounded"
        >
          Restore Layout
        </button>
      </div>

      <div className="mb-4">
        <h3 className="text-lg font-semibold mb-2">Active Groups:</h3>
        <div className="space-x-2">
          {updateColumnDefs().map(group => (
            <button
              key={group.groupId}
              onClick={() => toggleGroup(group.groupId!)}
              className={`px-3 py-1 rounded ${
                activeGroups.has(group.groupId!) 
                  ? 'bg-blue-500 text-white' 
                  : 'bg-gray-200'
              }`}
            >
              {group.headerName}
            </button>
          ))}
        </div>
      </div>

      <div className="ag-theme-alpine h-[600px]">
        <AgGridReact
          ref={gridRef}
          rowData={rowData}
          columnDefs={updateColumnDefs()}
          defaultColDef={{
            sortable: true,
            filter: true,
            resizable: true,
            flex: 1,
            minWidth: 100
          }}
          // Group features
          groupDisplayType="groupRows"
          suppressColumnMoveAnimation={false}
          animateRows={true}
          // Column group features
          allowDragFromColumnsToolPanel={true}
          enableColumnMoveAnimation={true}
          // State persistence
          maintainColumnOrder={true}
          // Enterprise features
          enableRangeSelection={true}
          enableColumnGrouping={true}
          suppressMovableColumns={false}
        />
      </div>
    </div>
  );
};
```



##### 6.1 Dynamic Sidebar Management
```typescript
// Sidebar configuration types
interface ISidebarConfig {
  toolPanels: {
    id: string;
    labelDefault: string;
    labelKey: string;
    iconKey: string;
    toolPanel: string | React.FC<any>;
    toolPanelParams?: any;
  }[];
  defaultToolPanel?: string;
  position?: 'left' | 'right';
}

// Modern sidebar implementation
const GridWithSidebar = () => {
  const [sidebarVisible, setSidebarVisible] = useState(true);
  const [activePanels, setActivePanels] = useState<string[]>(['columns', 'filters']);
  const gridRef = useRef<AgGridReact>(null);

  // Base sidebar configuration
  const getSidebarConfig = useCallback((visiblePanels: string[]): ISidebarConfig => ({
    toolPanels: [
      {
        id: 'columns',
        labelDefault: 'Columns',
        labelKey: 'columns',
        iconKey: 'columns',
        toolPanel: 'agColumnsToolPanel',
        toolPanelParams: {
          suppressRowGroups: true,
          suppressValues: true,
          suppressPivots: true,
          suppressPivotMode: true
        }
      },
      {
        id: 'filters',
        labelDefault: 'Filters',
        labelKey: 'filters',
        iconKey: 'filter',
        toolPanel: 'agFiltersToolPanel',
      },
      {
        id: 'stats',
        labelDefault: 'Statistics',
        labelKey: 'statistics',
        iconKey: 'chart',
        toolPanel: CustomStatsPanel
      }
    ].filter(panel => visiblePanels.includes(panel.id)),
    defaultToolPanel: visiblePanels[0],
    position: 'right'
  }), []);

  // Sidebar controls
  const handleToggleSidebar = useCallback(() => {
    setSidebarVisible(prev => !prev);
  }, []);

  const handleTogglePanel = useCallback((panelId: string) => {
    setActivePanels(prev => {
      if (prev.includes(panelId)) {
        return prev.filter(id => id !== panelId);
      }
      return [...prev, panelId];
    });
  }, []);

  const handleOpenPanel = useCallback((panelId: string) => {
    if (gridRef.current?.api) {
      gridRef.current.api.openToolPanel(panelId);
    }
  }, []);

  const handleClosePanel = useCallback((panelId: string) => {
    if (gridRef.current?.api) {
      gridRef.current.api.closeToolPanel();
    }
  }, []);

  return (
    <div className="w-full h-[600px]">
      <div className="mb-4 flex gap-2">
        <button
          onClick={handleToggleSidebar}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          {sidebarVisible ? 'Hide Sidebar' : 'Show Sidebar'}
        </button>
        
        <button
          onClick={() => handleTogglePanel('columns')}
          className="px-4 py-2 bg-green-500 text-white rounded"
        >
          Toggle Columns Panel
        </button>
        
        <button
          onClick={() => handleTogglePanel('filters')}
          className="px-4 py-2 bg-yellow-500 text-white rounded"
        >
          Toggle Filters Panel
        </button>
        
        <button
          onClick={() => handleTogglePanel('stats')}
          className="px-4 py-2 bg-purple-500 text-white rounded"
        >
          Toggle Stats Panel
        </button>
      </div>

      <AgGridReact
        ref={gridRef}
        sideBar={sidebarVisible ? getSidebarConfig(activePanels) : false}
        // ... other grid props
      />
    </div>
  );
};

// Custom stats panel component
const CustomStatsPanel: React.FC<any> = (props) => {
  const [stats, setStats] = useState({
    totalRows: 0,
    selectedRows: 0,
    filteredRows: 0
  });

  useEffect(() => {
    const updateStats = () => {
      const api = props.api;
      setStats({
        totalRows: api.getDisplayedRowCount(),
        selectedRows: api.getSelectedRows().length,
        filteredRows: api.getModel().getRowCount()
      });
    };

    props.api.addEventListener('modelUpdated', updateStats);
    props.api.addEventListener('selectionChanged', updateStats);

    return () => {
      props.api.removeEventListener('modelUpdated', updateStats);
      props.api.removeEventListener('selectionChanged', updateStats);
    };
  }, [props.api]);

  return (
    <div className="p-4">
      <h3 className="text-lg font-semibold mb-4">Grid Statistics</h3>
      <div className="space-y-2">
        <p>Total Rows: {stats.totalRows}</p>
        <p>Selected: {stats.selectedRows}</p>
        <p>Filtered: {stats.filteredRows}</p>
      </div>
    </div>
  );
};
```

##### 6.2 Dynamic Status Bar Management
```typescript
// Status bar configuration types
interface IStatusBarConfig {
  statusPanels: {
    statusPanel: string | React.FC<any>;
    align: 'left' | 'center' | 'right';
    key?: string;
    statusPanelParams?: any;
  }[];
}

// Modern status bar implementation
const GridWithStatusBar = () => {
  const [statusBarVisible, setStatusBarVisible] = useState(true);
  const [activeComponents, setActiveComponents] = useState<string[]>([
    'totalRows',
    'selectedRows',
    'filteredRows',
    'aggregation'
  ]);
  const gridRef = useRef<AgGridReact>(null);

  // Base status bar configuration
  const getStatusBarConfig = useCallback((visibleComponents: string[]): IStatusBarConfig => ({
    statusPanels: [
      {
        statusPanel: 'agTotalRowCountComponent',
        align: 'left',
        key: 'totalRows'
      },
      {
        statusPanel: 'agSelectedRowCountComponent',
        align: 'center',
        key: 'selectedRows'
      },
      {
        statusPanel: 'agFilteredRowCountComponent',
        align: 'right',
        key: 'filteredRows'
      },
      {
        statusPanel: CustomAggregationPanel,
        align: 'right',
        key: 'aggregation'
      }
    ].filter(panel => visibleComponents.includes(panel.key!))
  }), []);

  // Status bar controls
  const handleToggleStatusBar = useCallback(() => {
    setStatusBarVisible(prev => !prev);
  }, []);

  const handleToggleComponent = useCallback((componentKey: string) => {
    setActiveComponents(prev => {
      if (prev.includes(componentKey)) {
        return prev.filter(key => key !== componentKey);
      }
      return [...prev, componentKey];
    });
  }, []);

  return (
    <div className="w-full h-[600px]">
      <div className="mb-4 flex gap-2">
        <button
          onClick={handleToggleStatusBar}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          {statusBarVisible ? 'Hide Status Bar' : 'Show Status Bar'}
        </button>
        
        <button
          onClick={() => handleToggleComponent('totalRows')}
          className="px-4 py-2 bg-green-500 text-white rounded"
        >
          Toggle Total Rows
        </button>
        
        <button
          onClick={() => handleToggleComponent('selectedRows')}
          className="px-4 py-2 bg-yellow-500 text-white rounded"
        >
          Toggle Selected Rows
        </button>
        
        <button
          onClick={() => handleToggleComponent('aggregation')}
          className="px-4 py-2 bg-purple-500 text-white rounded"
        >
          Toggle Aggregation
        </button>
      </div>

      <AgGridReact
        ref={gridRef}
        statusBar={statusBarVisible ? getStatusBarConfig(activeComponents) : null}
        // ... other grid props
      />
    </div>
  );
};

// Custom aggregation panel component
const CustomAggregationPanel: React.FC<any> = (props) => {
  const [aggregation, setAggregation] = useState({
    sum: 0,
    average: 0,
    min: 0,
    max: 0
  });

  useEffect(() => {
    const calculateAggregation = () => {
      const api = props.api;
      const values = [];
      api.forEachNode(node => {
        if (node.data && typeof node.data.value === 'number') {
          values.push(node.data.value);
        }
      });

      if (values.length > 0) {
        setAggregation({
          sum: values.reduce((a, b) => a + b, 0),
          average: values.reduce((a, b) => a + b, 0) / values.length,
          min: Math.min(...values),
          max: Math.max(...values)
        });
      }
    };

    props.api.addEventListener('modelUpdated', calculateAggregation);
    return () => props.api.removeEventListener('modelUpdated', calculateAggregation);
  }, [props.api]);

  return (
    <div className="ag-status-bar-component flex items-center gap-4">
      <span>Sum: {aggregation.sum.toFixed(2)}</span>
      <span>Avg: {aggregation.average.toFixed(2)}</span>
      <span>Min: {aggregation.min.toFixed(2)}</span>
      <span>Max: {aggregation.max.toFixed(2)}</span>
    </div>
  );
};
```





### AG Grid Implementation Guidelines

#### Setup and Configuration
- Always import AG Grid components and styles properly:
```typescript
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';
```

- Use proper TypeScript interfaces for column definitions and row data:
```typescript
import { ColDef, GridOptions } from 'ag-grid-community';

// Use AG Grid's built-in types instead of custom interfaces
type RowDataType = {
  [key: string]: any;
  id: string | number;
}
```

#### Grid Configuration Best Practices
- Always define column definitions as constants outside the component:
```typescript
const columnDefs: ColDef[] = [
  { 
    field: 'id', 
    headerCheckboxSelection: true,
    checkboxSelection: true,
    showDisabledCheckboxes: true,
    width: 100 
  },
  { 
    field: 'name', 
    headerName: 'Full Name',
    filter: 'agTextColumnFilter',
    filterParams: {
      buttons: ['reset', 'apply'],
      closeOnApply: true
    }
  }
];
```

- Use AG Grid's default props for optimal performance:
```typescript
const defaultColDef: ColDef = {
  sortable: true,
  filter: true,
  resizable: true,
  flex: 1,
  minWidth: 100,
  filterParams: {
    buttons: ['reset', 'apply'],
    closeOnApply: true
  },
  sortingOrder: ['asc', 'desc', null]
};
```

#### Event Handling
- Implement grid event handlers using the "handle" prefix convention:
```typescript
// Modern AG Grid uses hooks for API access
const [gridApi, setGridApi] = useState<GridApi | null>(null);
const [columnApi, setColumnApi] = useState<ColumnApi | null>(null);

const handleGridReady = useCallback((params: GridReadyEvent) => {
  setGridApi(params.api);
  setColumnApi(params.columnApi);
}, []);

// Modern selection handling with type safety
const handleSelectionChanged = useCallback((event: SelectionChangedEvent) => {
  const selectedRows: RowDataType[] = event.api.getSelectedRows();
  // Handle selection
}, []);
```

#### Data Management
- Use AG Grid's built-in data management features:
```typescript
const [rowData, setRowData] = useState<RowDataType[]>([]);

// Modern data updates with immutable state
const handleDataUpdate = useCallback((newData: RowDataType[]) => {
  setRowData(newData);
}, []);

// For server-side operations
const handleServerSideData = useCallback((dataSource: IServerSideGetRowsParams) => {
  const { startRow, endRow, filterModel, sortModel } = dataSource.request;
  
  // Fetch data from server with proper params
  fetchData({ startRow, endRow, filters: filterModel, sorts: sortModel })
    .then(response => {
      dataSource.success({
        rowData: response.data,
        rowCount: response.totalCount
      });
    })
    .catch(error => {
      dataSource.fail();
      console.error('Data fetch failed:', error);
    });
}, []);
```

#### Performance Optimization
- Implement row virtualization for large datasets:
```typescript
<AgGridReact
  rowModelType="serverSide"
  serverSideInfiniteScroll={true}
  cacheBlockSize={100}
  maxBlocksInCache={10}
  blockLoadDebounceMillis={300}
  animateRows={true}
  suppressPaginationPanel={true}
  {...otherProps}
/>
```

- Use value getters for computed columns instead of storing computed values:
```typescript
const columnDefs: ColDef[] = [
  {
    field: 'fullName',
    valueGetter: (params: ValueGetterParams) => {
      if (!params.data) return '';
      return `${params.data.firstName} ${params.data.lastName}`;
    },
    // Modern AG Grid cell renderer with React
    cellRenderer: (props: ICellRendererParams) => (
      <span className="font-medium text-gray-900">
        {props.value}
      </span>
    )
  }
];
```

#### Styling Guidelines
- Use AG Grid themes with Tailwind:
```typescript
<div className="ag-theme-alpine h-[500px] w-full">
  <AgGridReact {...gridProps} />
</div>
```

- Customize grid appearance using AG Grid's theme parameters:
```typescript
// Modern AG Grid theme customization
const gridTheme = {
  '--ag-alpine-active-color': '#2563eb',
  '--ag-selected-row-background-color': '#eff6ff',
  '--ag-row-hover-color': '#f8fafc',
  '--ag-header-background-color': '#f8fafc',
  '--ag-header-height': '48px',
  '--ag-row-height': '40px',
  '--ag-header-foreground-color': '#1e293b',
  '--ag-font-family': 'Inter, system-ui, sans-serif',
  '--ag-font-size': '0.875rem',
  '--ag-grid-size': '4px'
};
```

#### Accessibility
- Implement proper ARIA labels and keyboard navigation:
```typescript
// Complete example of a modern AG Grid implementation
const GridComponent = () => {
  const containerStyle = useMemo(() => ({ height: '500px', width: '100%' }), []);
  
  return (
    <div 
      className="ag-theme-alpine-dark"
      style={{ ...containerStyle, ...gridTheme }}
      role="grid"
      aria-label="Data Grid"
    >
      <AgGridReact
        columnDefs={columnDefs}
        defaultColDef={defaultColDef}
        rowData={rowData}
        enableCellTextSelection={true}
        ensureDomOrder={true}
        rowSelection="multiple"
        suppressRowClickSelection={true}
        suppressCellFocus={false}
        enableRangeSelection={true}
        enableFillHandle={true}
        tooltipShowDelay={0}
        tooltipHideDelay={2000}
        onGridReady={handleGridReady}
        onSelectionChanged={handleSelectionChanged}
        getRowId={params => params.data.id}
      />
    </div>
  );
};
```

#### Error Handling
- Implement proper error boundaries for grid components:
```typescript
const handleGridError = (error: Error) => {
  console.error('AG Grid Error:', error);
  // Implement error handling logic
};
```

### Column Group Management

import React, { useState, useCallback, useRef } from 'react';
import { AgGridReact } from 'ag-grid-react';
import { ColDef, ColGroupDef, GridApi, ColumnApi } from 'ag-grid-community';

interface SampleData {
  id: string;
  q1: number;
  q2: number;
  q3: number;
  q4: number;
  year2022: number;
  year2023: number;
}

const ColumnGroupManagement: React.FC = () => {
  const gridRef = useRef<AgGridReact>(null);
  
  // Initial column definitions
  const [columnDefs, setColumnDefs] = useState<(ColDef | ColGroupDef)[]>([
    { field: 'id', headerName: 'ID' },
    {
      headerName: 'Quarterly Data',
      groupId: 'quarterlyGroup',
      children: [
        { field: 'q1', headerName: 'Q1' },
        { field: 'q2', headerName: 'Q2' },
        { field: 'q3', headerName: 'Q3' },
        { field: 'q4', headerName: 'Q4' }
      ]
    }
  ]);

  // Sample data
  const [rowData] = useState<SampleData[]>([
    { id: '1', q1: 100, q2: 200, q3: 300, q4: 400, year2022: 1000, year2023: 1200 },
    { id: '2', q1: 150, q2: 250, q3: 350, q4: 450, year2022: 1100, year2023: 1300 }
  ]);

  // 1. Add a new column group
  const addColumnGroup = useCallback((groupConfig: {
    headerName: string;
    groupId: string;
    children: ColDef[];
  }) => {
    setColumnDefs(prevCols => [
      ...prevCols,
      {
        headerName: groupConfig.headerName,
        groupId: groupConfig.groupId,
        children: groupConfig.children,
        marryChildren: true // Keeps children columns together
      }
    ]);
  }, []);

  // Example usage of addColumnGroup
  const addYearlyGroup = () => {
    addColumnGroup({
      headerName: 'Yearly Data',
      groupId: 'yearlyGroup',
      children: [
        { field: 'year2022', headerName: '2022' },
        { field: 'year2023', headerName: '2023' }
      ]
    });
  };

  // 2. Remove a column group
  const removeColumnGroup = useCallback((groupId: string) => {
    setColumnDefs(prevCols => 
      prevCols.filter(col => 
        'groupId' in col ? col.groupId !== groupId : true
      )
    );
  }, []);

  // 3. Update a column group
  const updateColumnGroup = useCallback((groupId: string, updates: Partial<ColGroupDef>) => {
    setColumnDefs(prevCols => 
      prevCols.map(col => {
        if ('groupId' in col && col.groupId === groupId) {
          return { ...col, ...updates };
        }
        return col;
      })
    );
  }, []);

  // 4. Add a column to an existing group
  const addColumnToGroup = useCallback((groupId: string, newColumn: ColDef) => {
    setColumnDefs(prevCols => 
      prevCols.map(col => {
        if ('groupId' in col && col.groupId === groupId && col.children) {
          return {
            ...col,
            children: [...col.children, newColumn]
          };
        }
        return col;
      })
    );
  }, []);

  // 5. Remove a column from a group
  const removeColumnFromGroup = useCallback((groupId: string, fieldToRemove: string) => {
    setColumnDefs(prevCols => 
      prevCols.map(col => {
        if ('groupId' in col && col.groupId === groupId && col.children) {
          return {
            ...col,
            children: col.children.filter(child => 
              'field' in child && child.field !== fieldToRemove
            )
          };
        }
        return col;
      })
    );
  }, []);

  // 6. Move column between groups
  const moveColumnBetweenGroups = useCallback(
    (columnField: string, fromGroupId: string, toGroupId: string) => {
      setColumnDefs(prevCols => {
        // Find the column definition to move
        let columnToMove: ColDef | undefined;

        // Create new columns array with the column removed from source group
        const columnsWithoutMoved = prevCols.map(col => {
          if ('groupId' in col && col.groupId === fromGroupId && col.children) {
            const [removed] = col.children.filter(
              child => 'field' in child && child.field === columnField
            );
            columnToMove = removed;
            return {
              ...col,
              children: col.children.filter(
                child => 'field' in child && child.field !== columnField
              )
            };
          }
          return col;
        });

        // Add the column to target group
        return columnsWithoutMoved.map(col => {
          if ('groupId' in col && col.groupId === toGroupId && col.children && columnToMove) {
            return {
              ...col,
              children: [...col.children, columnToMove]
            };
          }
          return col;
        });
      });
    },
    []
  );

  // 7. Save/restore column state
  const saveColumnState = useCallback(() => {
    if (!gridRef.current?.columnApi) return;
    
    const columnState = gridRef.current.columnApi.getColumnState();
    const groupState = gridRef.current.columnApi.getColumnGroupState();
    
    localStorage.setItem('gridColumnState', JSON.stringify({
      columns: columnState,
      groups: groupState
    }));
  }, []);

  const restoreColumnState = useCallback(() => {
    if (!gridRef.current?.columnApi) return;

    const savedState = localStorage.getItem('gridColumnState');
    if (!savedState) return;

    const { columns, groups } = JSON.parse(savedState);
    gridRef.current.columnApi.applyColumnState({ state: columns });
    gridRef.current.columnApi.setColumnGroupState(groups);
  }, []);

  // Example of using all the functions
  const demonstrateColumnGroupManagement = () => {
    // 1. Add a new year group
    addYearlyGroup();

    // 2. Update quarterly group header
    updateColumnGroup('quarterlyGroup', {
      headerName: 'Quarterly Performance'
    });

    // 3. Add a new column to yearly group
    addColumnToGroup('yearlyGroup', {
      field: 'year2024',
      headerName: '2024 (Projected)'
    });

    // 4. Remove Q4 from quarterly group
    removeColumnFromGroup('quarterlyGroup', 'q4');

    // 5. Move year2023 to quarterly group
    moveColumnBetweenGroups('year2023', 'yearlyGroup', 'quarterlyGroup');

    // 6. Save the state
    saveColumnState();
  };

  return (
    <div>
      <div className="mb-4 space-x-2">
        <button 
          onClick={addYearlyGroup}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add Yearly Group
        </button>
        <button 
          onClick={() => removeColumnGroup('quarterlyGroup')}
          className="px-4 py-2 bg-red-500 text-white rounded"
        >
          Remove Quarterly Group
        </button>
        <button 
          onClick={saveColumnState}
          className="px-4 py-2 bg-green-500 text-white rounded"
        >
          Save Column State
        </button>
        <button 
          onClick={restoreColumnState}
          className="px-4 py-2 bg-yellow-500 text-white rounded"
        >
          Restore Column State
        </button>
      </div>

      <div className="ag-theme-alpine h-[600px]">
        <AgGridReact
          ref={gridRef}
          rowData={rowData}
          columnDefs={columnDefs}
          defaultColDef={{
            sortable: true,
            filter: true,
            resizable: true,
            flex: 1,
            minWidth: 100
          }}
          suppressColumnMoveAnimation={false}
          allowDragFromColumnsToolPanel={true}
        />
      </div>
    </div>
  );
};

export default ColumnGroupManagement;

